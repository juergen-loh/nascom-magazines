<?php columnStart(1); ?>
<p>
12
</p>
<p>
well, whereas others don&rsquo;t work at all even though they compile perfectly. It
seems likely to me that Rory O&rsquo;Farrell will write the definitive review of the
compiler, and tell you all the things I should have, so I am going to change
the subject, leaving you with a free gift in the form of a useful Pascal
procedure that is all my own work. It is not particularly elegant, and is
probably not the best way to do what it does, but it does have the great merit
that it does work. It also proves that you can learn Pascal without having to
</p>
<p>
have as many brains as Zaphod Beeblebrox...
</p>
<p>
PROCEDURE JUSTIFY;
</p>
<p>
VAR
PTRA, PTRB, I : INTEGER;
LINEFULL : BOOLEAN;
</p>
<p>
BEGIN
</p>
<p>
LINEFULL := TRUE;
PTRA :
PTRB :
REPEAT
</p>
<p>
BEGIN
{Test to see if there&rsquo;s more than a full line of text left.}
</p>
<p>
FOR I:= 0 TO WIDTH DO
IF REPLY[PTRB+I| = CHR(13) THEN LINEFULL := FALSE;
IF LINEFULL
THEN
{Do this if there is a full line.}
BEGIN
{Look one line ahead.}
PTRA := PTRB + WIDTH;
{If not at a space, come back a bit.}
WHILE REPLY[PTRA] &lt;&gt; CHR(32) DO
PTRA := PTRA &ndash; 1;
{Now print what is between the pointers. }
FOR I := PTRB TO PTRA &ndash; 1 DO
WRITE(REPLY[I]);
{Print a CR LF if necessary. }
IF PTRA &lt; PTRB + WIDTH
THEN
BEGIN
WRITE(CHR(13));
WRITE(CHR(10))
END;
{Set pointers to do next line.}
PTRA := PTRA + 1;
PTRB := PTRA
END
ELSE
{Do this if there is not a full line. }
BEGIN
{Find the end of the text.}
WHILE REPLY[PTRA| &lt;&gt; CHR(13) DO
PTRA := PTRA + 13
{Print the remaining text.}
FOR I := PTRB TO PTRA &ndash; 1 DO
waree (Rerun);
{Print a CR LF.
WRITE(CHR(13));
WRITE(CHR(10))
END;
</p>
<p>
&lsquo;
$
.
,
</p>
<p>
Woof
ns aera
</p>
<p>
END
UNTIL NOT LINEFULL
END;
</p>
<?php columnEnd(1); ?>
