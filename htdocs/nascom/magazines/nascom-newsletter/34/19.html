<?php columnStart(1); ?>
<p class="continued">
from element number 125 to element number 327 inclusive by ID
No., then we can use something like&hellip;
</p>
<p class="indent">
100 F=125:L=327-125+1:D=1<br>
110 A=USR(0)DA$(F),L,1,8,D
</p>
<p class="continued">
Double dimensioned arrays are not supported but&hellip;
</p>
<p class="indent">
A=USR(0),DD$(1,1),50,1,10,5
</p>
<p class="continued">
Wil sort the array from DD$(1,1) to DD$(50,1) without reference
to any other dimensions. ie. the elements DD$(1,2) to DD$(50,2)
will remain in their previous sequence. Perhaps BruteSort II
will properly support multi-dimensioned arrays but I can
visualise the 1000 element sort dragging on for quite a bit
longer with that enhancement.
</p>
<p>
The penalty paid for having such brief code is that there is
no validation of the parameters and it&rsquo;s also fussy about syntax
(extra blanks, etc.). Its up to the BASIC calling program to
check that all parameters are within valid range. Another
limitation is that all the elements in the array should have
characters filling the entire sort field. Sorting field 1 to 10
on a 6 character string may have unpredictable results and an
array with a null string in the sort range will most likely get
corrupted.
</p>
<p>
With some more understanding of how BASIC works the routine
could be polished up a bit to remove these restrictions. Who is
going to be first with SuaveSort?
</p>
<p>
I would be glad to hear from any other Nascomaniacs in Saudi
Arabia (or anywhere else for that matter). I can be contacted
via
</p>
<p class="indent">
J.R. McAfee<br>
c/o Saif Establishment<br>
P.O. Box ___<br>
Al-Khobar<br>
Saudi Arabia
</p>
<?php imageInsert($imagepath, $magpath, $issuepath, $pagepath, "Image-19-1.png"); ?>
<?php columnEnd(1); ?>
