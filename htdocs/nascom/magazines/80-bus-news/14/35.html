<?php columnStart(1); ?>
<p>
An off shoot of presenting the date is the ability to use the date in
numerical sorts. The obvious method is split a date into its component parts,
using the tens and units of the year, the month and the day; so that 21 /09 /82
would end up as 820921. This would work as each day is a unique number and days
increase in ascending order. However, the number sequence is not contiguous which
could cause a number of problems, not the least of which is the complicated
validation to determine if a date is missing within a sequence of dates, or
possibly an extra day having been entered in error. Whilst initially attractive,
the method of using the date backwards has a number of disadvantages. Better then
that the number sequence be contiguous. This can be achieved by starting at a
base date and counting upwards. The only problem then is to decide the base date
and how to cope with leap years, etc.
</p>
<p>
A numeric sequence often used for this is the Julian date. Based on the
year nought. It is accurate but is confused by the normal slippage of leap years
every four hundred years, also by the abnormal leap year skip which occurs every
4000 years. The next modulo 4000 leap year correction takes place in the year
2000, and the one after that in the year 6000. The one in the year 2000 might be
of interest, but the one in the year 6000 will probably only be important to
someone with an interest in cryogenics. However, for general purposes, the Julian
number has a lot going for it.
</p>
<p>
To convert an input date to a Julian number the following simple routine
may be used, it does assume that the date will be this century.
</p>
<p>
3000 INPUT &ldquo;Date (DD/MM/YY) &ldquo;;DT$
</p>
<p>
3010 DAY=VAL(LEFT$(DT$,2)) : MONTH=VAL(MID$(DT$,4,2)) : YEAR=1900+VAL(RIGHTS(DT$,2))
3020 DT=INT(30.57*MONTH )+INT(365.25*YEAR-395 .25+.5)+DAY
</p>
<p>
3030 IF MONTH &gt;2 THEN IF INT(YEAR/4)=YEAR/4 THEN DT=DT-1 ELSE DT=DT-2
</p>
<p>
3040 &lsquo; DT now equals the Julian number.
</p>
<p>
This is all very good, the conversion back again is also simple, with the
addition in this case to convert the number to a string in the same form as the
input.
</p>
<p>
A000 Y=INT(DT/365.26)+1
</p>
<p>
4010 D=DT+INT (395 .25-365.25*Y+.5)
</p>
<p>
4020 IF INT(Y/4)*4=Y THEN Di=1 ELSE D1=2
</p>
<p>
4030 IF D&gt;91-D1 THEN D=D+Di
</p>
<p>
4040 MONTH=INT(D/30.57)
</p>
<p>
A050 DAY=D-INT(30.57*MONTH )
</p>
<p>
4060 IF M12 THEN M=1 : Y=Y+1
</p>
<p>
4070 YEAR=Y-1 900
</p>
<p>
4080 D$=RIGHTS(STRS(DAY),LEN(STR$(DAY))-1) : IF DAY&lt;=9 THEN D$="0"+D$
4090 J$=SPACE$(2) : LSET J$=D$ : DT$=J$+"/&rdquo;
</p>
<p>
4100 M$=RIGHT$(STR$(MONTH) , LEN(STRS(MONTH))-1) : IF MONTH&lt;=9 THEN M$="0"+M$
4110 J$=SPACE$(2) : LSET J$=M$ : DTS=DT$+M$+"/&rdquo;
4120 Y$=RIGHT$(STR$(YEAR) , LEN(STR$ (YEAR) )-1 )
</p>
<p>
4130 J$=SPACE$(2) : LSET J$=Y$ : DI$=DT$+J$
</p>
<p>
4140 &lsquo; DT$ now equals the date string
</p>
<p>
So having started with clock hardware, I have finished with Julian dates.
Time is an interesting subject, you can do so much with it. I only wish there
were a program to provide me with about forty hours in a day, then perhaps I
would have time to do everything I wish to do and still find time to sleep.
</p>
<p>
</p>
<?php columnEnd(1); ?>
