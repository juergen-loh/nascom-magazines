<?php columnStart(1, "noindent"); ?>
<p>
invoke Wordstar wait until Wordstar has loaded and has started on its first
screen display. (It seems to &lsquo;swallow&rsquo; the odd character if you start too
soon.) You can than type (without any pauses) a command like
<b>DARTICLE.DOC<?php spChar("zwsp"); ?>&lt;RETURN&gt;<?php spChar("zwsp"); ?>^QFKeyboards<?php spChar("zwsp"); ?>&lt;RETURN&gt;<?php spChar("zwsp"); ?>2<?php spChar("zwsp"); ?>&lt;RETURN&gt;.</b> This magic invocation (for
those unfamiliar with Wordstar) would open a document file ARTICLE.DOC, start
to load it into the memory buffer, search through the file and put the cursor
at the second occurrence of the word &ldquo;Keyboards&rdquo;. WORDSTAR would do this
without all the normal in-built delays, and also without bothering to display
the first page of the document.
</p>
<p>
One very useful feature came in with release 2.0 of IVC-MON. At this time
Gemini introduced a new keyboard,
<?php externalLink("GM827","",""); ?>,
which included a row of extra
function keys along the top, together with a numeric pad on the right-hand
side. IVC-MON 2.0 catered for this keyboard, and while providing default
settings for these extra keys, it allowed users to define alternative
character strings for them (including the numeric pad). Note the use of the
word &ldquo;strings&rdquo;. If required, pressing one of these keys can result in an
entire sentence (or paragraph!) being returned by the
<?php externalLink("IVC"); ?>.
I find them useful
in a variety of contexts: During program development they can be used as an
instantaneous SUBMIT feature (e.g. define a key as <b>&lt;M80 =PROG^M L80
PROG,<?php spChar("zwsp"); ?>PROGLIB,<?php spChar("zwsp"); ?>PROG<?php spChar("zwsp"); ?>/N/E^M&gt;</b> &ndash; which runs the assembler followed by the linking
loader). For standard programs they can be set up to suit the program&rsquo;s
command codes. (e.g. Keys for INSERT, DELETE etc in editors). Oft used words
or phrases can be put a single key (e.g. Please send the money).
</p>
<p>
The keyboard port on the IVC is an 8-bit port that is sub-divided into 7 data
bits and a strobe pulse. This meant that some way had to be found for the IVC
to distinguish the special function keys from the 128 standard ASCII
characters that are generated by the other keys on the keyboard. This was done
by having the GM827 keyboard return double-byte codes for the special keys,
and, as the ESCAPE code (0Bh) was chosen as the lead-in code, the ESCAPE key
is in fact one of the special keys. (The IVC-MON software however does not
allow it to be reprogrammed to an alternative code or character string.)
</p>
<p>
Every time one of these special double-byte codes is received, the IVC
converts it to a single byte code in the range 80H-BDH and stores the byte in
the keyboard buffer. (Note that the normal keys can only produce codes in the
range 00-7FH.) When the IVC passes bytes from the keyboard buffer to the host
system it checks the msb of each byte. If the msb is found to be set it then
looks for that keycode in an internal table it has its workspace RAM. The code
in the table marks the start of the string that is to be sent in place of the
function key. IVC-MON then sets a flag to say &ldquo;get characters from this string
rather than the keyboard buffer&rdquo;, which remains set until the string is
exhausted. One point to notice from this is that a function key only uses up
one byte of the &lsquo;type ahead&rsquo; buffer. So, if you&rsquo;re somebody who often goes
charging ahead of PIP or your assembler, and occasionally &ldquo;bust&rdquo; the buffer,
the answer is to put some of your typing under function keys (if this is
possible). The programmable function keys I find a powerful feature, and this
the IVC provides at zero overhead to the Host system thanks to it having its
own processor on-board.
</p>
<h3 id="article1">
IVC-MON Release history.
</h3>
<table class="indentCol1">
<tr><td colspan=2>Vers.</td></tr>
<tr><td>1.0</td><td>The original release.</td></tr>
</table>
<?php columnEnd(1); ?>
