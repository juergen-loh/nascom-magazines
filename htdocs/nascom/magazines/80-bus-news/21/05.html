<?php columnStart(1); ?>
<p class="continued">
has, giving the example:
</p>
<pre class="indent">
A$ = LEFT$(B$,4) + MID$(A$,3,3) + " Wowee!"
</pre>
<p>
In fact, Pascal has these facilities in exactly the same way as BASIC:
they may or may not be provided with the compiler/<?php spChar("zwsp"); ?>interpreter as &ldquo;standard&rdquo; or
&ldquo;intrinsic&rdquo; functions. Most of the Pascal compilers around, of course, are really
only &ldquo;Tiny&rdquo; Pascals (i.e. a subset) and many don&rsquo;t even allow the user to define
his/<?php spChar("zwsp"); ?>her own data types (the solution suggested by Dr. Dark). The Nascom Pascal,
approved by Lucas Logic, however, does indeed have the relevant functions and is
probably one of the few Tiny Pascals which do.
</p>
<p>
Most of the Pascal implementations which reproduce, or nearly reproduce,
the full Jensen and Wirth specification will also fling such functions in as
standard intrinsics as a matter of course. In
<?php externalLink("UCSD Pascal","",""); ?>, for instance, Dr.
Dark&rsquo;s line of BASIC could be re-written as:
</p>
<pre>
   astring := concat(copy(bstring,1,4),<?php spChar("zwsp"); ?>copy(astring,3,3),<?php spChar("zwsp"); ?>" Wowee!");
</pre>
<p>
where astring and bstring (and the functions copy and concat) are STRING types
(equivalent to PACKED ARRAY OF CHAR of dynamic length).
</p>
<p>
Elsewhere
<a href="../../../14/06/text/#article1">in the same article</a>
he attempts to tackle the problem of
handling integers with a large number of digits. Again, if he had UCSD he would
not have to do it the hard way. UCSD Pascal allows the use of a standard data
type called LONGINTEGER which can be declared to an arbitrary precision up to 36
digits and can then be used with the usual arithmetic operations.
</p>
<p>
Big H,
<a href="../../../14/11/text/#article1">in the same issue</a>,
details his method of utilising other
&ldquo;Centronics"&rdquo; signals besides BUSY and /STROBE. However, his <?php externalLink("Z80 PIO", "PIO"); ?> Port assignments
are not consistent with existing conventions for BUSY and /STROBE. Both Nascom
and Gemini, I believe, now employ the convention that Port B is used for data and
Port A for control with bit 0 assigned to BUSY and bit 1 to /STROBE. It would be
helpful if other pioneers could maintain consistency as they progess further into
the jungle!
</p>
<p>
On my own system I am experimenting with the assignment for Port A:
</p>
<table class="indent">
<colgroup><col style="width: 3em"><col style="width: 12em"><col></colgroup>
<tr><td>BIT</td><td>FUNCTION</td><td>I/O?</td></tr>
<tr><td>0</td><td>BUSY</td><td>I</td></tr>
<tr><td>1</td><td>/STROBE</td><td>O</td></tr>
<tr><td>2</td><td>PE (Paper Empty)</td><td>I</td></tr>
<tr><td>3</td><td>Not used</td><td></td></tr>
<tr><td>4</td><td>Not used</td><td></td></tr>
<tr><td>5</td><td>/INIT</td><td>O</td></tr>
<tr><td>6</td><td>/AUTO FEED XT</td><td>O</td></tr>
<tr><td>7</td><td>/ERROR</td><td>I</td></tr>
</table>
<p class="continued">
/ERROR, in particular, is assigned to bit 7 so that a simple RLA will enable the
Carry flag to show its status.
</p>
<p class="noindent">
Hope this is helpful......
</p>
<p class="noindent">
Mike York, London.
</p>
<?php hline("20%"); ?>
<?php columnEnd(1); ?>
