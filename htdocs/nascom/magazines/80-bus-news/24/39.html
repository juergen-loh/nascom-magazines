<?php columnStart(1); ?>
<table style="margin: auto">
<tr><td>5&Prime; Pertec GEMDDDS format</td><td>8 mins 6 secs</td><td>(15 tracks)</td></tr>
<tr><td>5&Prime; Microp. GEMQDSS format</td><td>8 mins 40 secs</td><td>(40 tracks)</td></tr>
<tr><td>8&Prime; Standard Single density</td><td>6 mins 20 secs</td><td>(43 tracks)</td></tr>
<tr><td>R0201 Winchester</td><td>1 min 42 secs</td><td>(85 tracks)</td></tr>
<tr><td><?php externalLink("GM833"); ?> RAM-DISK</td><td>17 secs</td><td></td></tr>
</table>
<p>
The RAM-DISK figure is not a mis-print, it is just 17 seconds. This test
is perhaps a little artificial, so the next benchmark is the time taken to PIP
a source file from the Winchester to the destination drive, load M80 (from the
drive under test), assemble it, then link and load it using L80.
</p>
<table style="margin: auto">
<tr><td>5&Prime; Pertec GEMDDDS format</td><td>2 mins 34 secs</td></tr>
<tr><td>5&Prime; Microp. GEMQDSS format</td><td>2 mins 35 secs</td></tr>
<tr><td>8&Prime; Standard Single density</td><td>2 mins 39 secs</td></tr>
<tr><td>RO201 Winchester</td><td>2 min 00 secs</td></tr>
<tr><td><?php externalLink("GM833"); ?> RAM-DISK</td><td>1 min 30 secs</td></tr>
</table>
<p>
Here the performance difference is not so marked, but it is still
significant. (This shows that in this instance the majority of the total time
taken was in actual processing time and not disk access time.) The floppy
disks had an edge on the Winchester as they only started off with M80 and L80
on them. By comparison the Winchester was already holding 3.9Mbytes of data
and programs, and the files created during the test filled in odd holes here
and there on the disk, and weren&rsquo;t stored in successive blocks. Also the head
was on average about 200 tracks away from the directory track for most of the
time!
</p>
<h3 class="uppercase">
<u>Caveat</u>
</h3>
<p>
Using the RAM-DISK requires a careful approach to work to ensure that at
the end of the day all changed and new programs end up back on permanent
storage (disk). Copying a file to disk as soon as it is changed rather defeats
one of the benefits of the RAM-DISK, but it has to be remembered that the RAM-DISK
is volatile. Though the Gemini BIOS does not obliterate files if you are
forced to press the reset switch, it cannot protect you against accidental (or
deliberate!), powering down.
</p>
<p>
This is the time when the programmable function keys of the Gemini
keyboard come into their own. At the start of a session one (or more) can be
programmed up to provide a backup command, (e.g. PIP A:=M:*.MAC^M), and then
this key can be pressed at idle moments when you pause for thought (or answer
the phone), and, finally, at the end of the session.
</p>
<p>
[Ed.&nbsp;&ndash; In one application that I know a RAM-DISK is being used, its
volatility does not matter. The application requires as rapid as possible
access to any record in a very large database. When it is started the program
copies a number of index files to the RAM-DISK, and uses these to control
access to the database. If the power fails nothing of importance is lost.]
</p>
<h3 class="uppercase">
<u>Error Protection?</u>
</h3>
<p>
One area open to debate is whether, with so much memory on the board,
GM833 should incorporate some form of error detection/<?php spChar("zwsp"); ?>protection? The soft
error rate of RAMS is very low, but here we have 64 of them in an array (plus
an additional 8 in the system memory).
</p>
<p>
Error detection and correction would be an overkill in this environment,
but a possibility lies in a simple parity check on each byte. (I note a number
of the large memory expansion boards for the IBM&nbsp;PC now offer parity protected
memory). This would add eight more dynamic RAMs to the board, along with the
parity generation/<?php spChar("zwsp"); ?>check logic (assuming it could all be fitted on). It also
raises the question of what to do in the event of a parity error being
detected. Light a LED? Generate an interrupt? Halt?
</p>
<?php columnEnd(1); ?>
