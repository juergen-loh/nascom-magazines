<?php columnStart(1); ?>
<p>
32
</p>
<p>
Control mechanisms
All the usual controlling mechanisms are available to you these are
</p>
<p>
if&lt;condition&gt; ... else...
for(&lt;loop start&gt; ; &lt;loop end conditiom&gt; ; &lt;loop step&gt; )...
do ... while&lt;condition&gt;
while&lt;condition&gt;...
and the very handy -switch&reg;&rdquo; multiple condition mechanism.
</p>
<p>
if.. else and do.. while require no explanation but I would just like to
run through the for loops and switch statements. &ndash;
</p>
<p>
The for loop in the example program went like this:
for(count=0; count &lt;= 100; count++) putw(count, fd);
</p>
<p>
This translates as set count to 0, WHILE count is less than or equal to
100 call the putw function to output the value of count to the disk file, and
at the end of each iteration increment the value of count by 1 (count++).
</p>
<p>
This is the normal format of any for loop but I don&rsquo;t see any reason why
you could not put fred&lt;=100 instead of count&lt;=100 to make the end condition
dependant upon some other variable and give you added flexibility.
</p>
<p>
The switch statement is a pearl and saves you the agony of entering
multiple if conditions. It is ideal for menu driven applications. A typical
example may be:
</p>
<p>
switch( value) /*&reg; value is a variable */
{
case I:
functionl();
break;
</p>
<p>
case 2:
function2();
break;
</p>
<p>
case 3:
function3();
break;
</p>
<p>
default:
printf&pound;("ERROR &ndash; illegal option");
errflag = TRUE;
</p>
<p>
Tests are done on &ldquo;value&rdquo; and if it is found to be 1, 2, or 3 then the
appropriate function is called and on return the case structure is exited via
the -break&rsquo; statement. If none of the valid cases are found to be true the
</p>
<?php columnEnd(1); ?>
