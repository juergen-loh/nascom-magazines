<?php columnStart(1); ?>
<h1 id="article1">
<?php imageInsertMgz("Image-58-1.png"); ?>
</h1>
<?php columnEnd(1); ?>
<?php columnStart(2); ?>
<h2 class="uppercase">
<u class="double">Book Review</u>
</h2>
<?php columnChange(2); ?>
<h3 class="author">
By Rory O&rsquo;Farrell
</h3>
<?php columnEnd(2); ?>
<?php columnStart(1); ?>
<h4>
<span class="uppercase">Software</span> TOOLS by B.W.Kernighan and P.J.Plauger, published by Addison Wesley.
</h4>
<p>
There are few books that make a significant contribution to one&rsquo;s
thinking. I doubt if anyone who has read this book has been utterly unaffected
by it. The authors state that the purpose of the book is to teach how to write
good programs that make good tools. They do this by presenting a set of
programs which are designed to stand on each others shoulders to build into a
full set of tools. The point is made that frequently one has to lash up a
little program to do a specific thing &ndash; as it might be to count words &ndash; and
when the purpose of the program has been met, the program is discarded. It is
the contention of the authors that such a program is a tool, and should not be
discarded. Moreover, they suggest that the quick lash up, while it gets the
job done, suffers from a lack of thought and documentation. This lack of
thought and documentation means that, if the program is resurrected at some
stage, it is almost incomprehensible, and that the resurrector, even though he
may be the author in the first instance, may well find it easier to rewrite
the entire program from scratch.
</p>
<p>
Kernighan and Plauger set out in this book to illustrate a collection
of general purpose tools &ndash; a series of programs which can readily be called on
to do certain jobs. They discuss in a readable and clear way, the criteria
involved in the design, the problems of implementation, and above all the
flexibility of a good tool. If after reading this book, all one got from it
was the discipline of clear thinking, that alone would be worth the price. But
it is possible to actually implement the programs in this book on a machine,
and their utility might be worth many times the book cost.
</p>
<p>
The programs are written for the most part in a language called RATFOR
(RATional FORtran). This is so similar to structured English that it need
cause no great concern. Some of the examples are also given in PL/1, which is
similar to Pascal. It is a trivial matter to translate the clear structure of
these programs to any machine language, or (better still) to higher level
languages. I remember that the point has been made (but I can&rsquo;t find the
reference) that the programs are not necessarily the most efficient in the
world, but that one&rsquo;s own time is more important than the computer&rsquo;s.
</p>
<p>
How true this is of the Nascom owner. Do you care if your poor
hardworked Nascom has to stay up all night? No, you don&rsquo;t, as long as the job
is done when you want it!
</p>
<p id="article2">
In this book, a number of simple programs such as count a character,
count a word etc., are introduced early on. Building on these, the book then
proceeds to discuss file structures, sorting, text patterns, text editing,
formatting of output, up to the level of formatting for composing machines
(the book is photset, using some of their own tools, and one couldn&rsquo;t tell it
from a &ldquo;real&rdquo; book!), a microprocessor, and concludes with a RATFOR &ndash; Fortran
Preprocessor. It would even be possible to convert that to a RATFOR-BASIC
translator. It makes the minimum assumptions about the underlying operating
system, dealing in a few primitives such as &ldquo;Get a char&rdquo;, &ldquo;Put a char&rdquo;.
</p>
<p>
I would suggest that this book is not for the absolute beginner, but
anyone with a little experience fiddling around on a microcomputer should find
it exciting and profitable to read.
</p>
<?php hline("20%"); ?>
<?php columnEnd(1); ?>
