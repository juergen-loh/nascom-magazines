<?php columnStart(1); ?>
<h3>
Compiled This and That
</h3>
<p>
One thing is apparent, and seems to owe something to the growing &lsquo;maturity&rsquo;
(if that&rsquo;s the word) of the software writers for PC type machines, or, perhaps
it&rsquo;s main frame practices creeping in. That is, as little as possible is
written at assembler level. Most applications encountered seem to be compiled
this, or compiled that, or they don&rsquo;t say they are compiled, but the sheer size
of the object code sere they must be. Now, I&rsquo;ve got nothing against compilers,
in fact most of what I&rsquo;ve been doing over the last few months has been compiled,
so I don&rsquo;t knock it. But when I look at compiled object, its size says that it
can&rsquo;t possibly be as efficient as good old hand written assembler. In fact of
course, this could not be, but it depends on where you place your benchmarks as
to what determines efficiency. Taking hand written assembler as a base line,
one could argue that a compiler is several hundred percent more efficient when
compared with the time taken to write an equivalent program in assembler. Or it
could be argued that compiled code is only some tens of percent efficient when
it comes to the size of the programs created, the same applies to operating
speed. Now I don&rsquo;t intend to get into any arguments about benchmarks, I&rsquo;ll
leave that to Paddy Coker; but it seems to me that comparing the &lsquo;goodness&rsquo; of
anything must take into account all these things (and probably a few more
parameters I don&rsquo;t see right now) and not just confine itself to the operating
speed of a program! Just how and where you adjust the trade-off, I don&rsquo;t know.
</p>
<p>
Now there are compilers for this language, and that language and each has
its advantages and disadvantages. Of the compilers around, I favour those
languages which have matching interpreters; as an interpreted program is usually
much easier to edit than one you have to recompile every time you have tweaked
it. An interpreter is invaluable in the early stages of learning a language on
your own, in getting round the inevitable syntax errors caused by such things as
laving off semicolons on the ends of lines in Pascal and C programs, very
frustrating as the compiler stops every time it hits an error. Of the languages
available, I use a very few, being a very pedestrian type who hates having to
learn anything new; you can certainly list them on the fingers of one hand,
BASIC &ndash; fairly proficient, C &ndash; pretty hopeless, DBASE &ndash; very good (although I
say so myself, I get lots of practice), and <span class="uppercase">Pascal</span> &ndash; forget it. I&rsquo;ve recently
heard of a C interpreter, so I&rsquo;m keen to get my hands on that and brush up my C
a bit. But in the main, armed with the two languages I feel competent with and
a bit of assembler to &lsquo;paper over the cracks&rsquo; caused by the deficiencies of the
compilers, I feel ready to tackle most things.
</p>
<h3>
Software Packages
</h3>
<p>
As to applications/<?php spChar("zwsp"); ?>utility software I use, I have found that SIDEKICK is
perhaps the most invaluable. The major features are that it is memory resident,
so it&rsquo;s always available (and always knows exactly what you were doing last) and
consists most usefully of a calculator in decimal, binary and Hex, a calendar
with appointments dairy, and a mini word processor, well a context editor
really. The context editor endears itself particularly as it is very similar in
the way it works to a convenient cross between GEMPEM and WORDSTAR. The text is
RAM resident (so it won&rsquo;t handle large files) whilst most of the control codes
are WORDSTAR compatible. There are a lot of other frills as well, including a
phone directory and dialler, but I don&rsquo;t use them. I&rsquo;ve tried several different
versions of SIDEKICK-like things, but still I always come back to SIDEKICK.
</p>
<h3>
Memory Resident Quirks
</h3>
<p>
Mind you, memory resident software has to be treated with a certain
caution. Strange things happen. I&rsquo;m told, not actually seen myself, that
SIDEKICK hooks itself into the keyboard, looking for a certain keyboard key
press combination to see if it&rsquo;s required. To that end, it redirects the
keyboard interrupt vector to itself for examination prior to sending on the key
press to where-ever it was going in the first place. Ok, now that&rsquo;s logical,
but SIDEKICK could fall over if another program redirected the keyboard
interrupt vector to ITSELF. SIDEKICK is sneaky, to ensure this doesn&rsquo;t happen,
SIDEKICK has also hooked itself into the &lsquo;clock tick&rsquo; interrupt, so that
SIDEKICK gets woken up about 16 times a second. On waking up, SIDEKICK looks at
</p>
<?php columnEnd(1); ?>
