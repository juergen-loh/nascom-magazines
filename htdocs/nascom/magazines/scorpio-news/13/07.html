<?php columnStart(1); ?>
<p>
and didn&rsquo;t have to curse very many times, but I have to admit I was surprised at
having to do this. Then I thought how much more money <?php externalLink("HiSOFT","Hisoft"); ?> might have wanted
from me if they had had to do the job, and I decided it was a good way to update
a manual...
</p>
<p>
Modern Hisoft manuals are good, and full of useful advice for first time users,
without having too much of it. (The old ones, as I remember, were rather hard
work to use and to read; we all have to start somewhere.) This manual contains
a section describing the improvements over HP4, which corresponds very closely
with what I wrote ages ago about the parts of Pascal that HP4 couldn&rsquo;t do,
although I don&rsquo;t suppose for a moment that I had anything to do with this. For
instance Variant records are now possible, as are files of type another than
text. I have not yet needed to use a variant, but I used to hate having to save
integers, reals and booleans as text.
</p>
<p>
You still can&rsquo;t have files of files, but who wants then? (Cue for at least
twenty angry letter from academics.) Another new feature is that the compiler
can now cope with such bigger programs, because it saves each routine to disk as
it is compiled. The symbol table is twice as big, too, not that I ever managed
to fill the old one. Reserved words can now be in lower case, if you like,
Apple Pascal always used to look nice because of that, but it isn&rsquo;t vital, just
a thoughtful touch.
</p>
<p>
The manual gives detailed descriptions of the syntax and semantics expected by
the compiler, and describes the various predefined identifiers that are
available to the programmer. Once again, I will save a lot of space by not
copying out a great list of these, as they are almost all exactly the same as
any other Pascal. Instead I&rsquo;ll attempt to restrict myself to writing about the
interesting, or changed, parts.
</p>
<p>
a major new feature of the system supplied is the appearance of a menu at the
start of operations. This offers a choice of editing a program, compiling it,
running 1t, executing it (which means compile AND then run) or quitting. It is
rather like the options offered by p-systems Pascals. The editor is the now
standard Hisoft program editor that I have described before, and can of course
be modified for the
<?php externalLink("SVC"); ?>
as mentioned in the
<a href="../../../12/18/text/#article1">last article</a>.
This time, however,
when you exit from editing, the menu reappears, and you can compile the program
from there with a single keypress. This really does save a lot of tine,
compared with the long commands one had to enter to use earlier versions of the
compiler, especially if one is being naughty and programming and debugging at
the keyboard. Slapped wrist from Niklaus Wirth if he catches you at it. If by
some mysterious chance your program contains a syntax error, and the compiler
spots it, you no longer get a mystery number on the screen and and have to dive for the
manual. The error messages are in English. Yet another major advance, not that
I ever see error messages, of course...
</p>
<p>
The New, Mark Dispose and Release procedures have been changed so that they now
conform with Wirth&rsquo;s standard, and this allows more sophisticated use of dynamic
variables, without which fancy list handling is out of the the question. You can do
astounding things with lists, dear BASIC users. The Inline and User procedures
allow you to put in machine code, if necessary. This is, of course, disgusting
to all who regard programming as an abstract art form. Have you noticed how
slow their programs are? Peek, Poke, Inp and Out give you access directly to
memory and Z80 ports, and are consequently vital if you want to write programs
that work, say, a Plato, or indeed, any of the other 80-BUS boards that expect
to be accessed via Z80 ports.
</p>
<p>
The most tremendously useful of all the new procedures, however, is Chain. It
loads and runs another program, so now it is possible to write vast systems of
programs, way beyond the size of memory. And they don&rsquo;t have to communicate
with each other in the clumsy way I once advocated, by passing data in files,
either. As long as the variables used in more than one program are global
variables, and are declared in the same order in each program, they will stay in
memory ready for the next program to use them. The best way to do this, says
the manual, is to store all these declarations in a file, and use the compiler&rsquo;s
&lsquo;include&rsquo; option to read in this file as each program is compiled. Thhis
</p>
<?php columnEnd(1); ?>
