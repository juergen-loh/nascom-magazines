<?php columnStart(1); ?>
<p>
When writing CP/M records to disk, the BIOS computes the physical sector number im the same
manner as for reading. It then checks to see if that physical sector is already in the buffer and
reads it if not. This pre-read of physical sectors explains why the disk performance is not quite
as good when writing compared with reading. However, the performance achieved is still better
than when writing byte sectors as the disk is still only accessed twice for every four CP/M
records written.
</p>
<p>
The pre-read may be skipped under certain circumstances. CP/M tells the BIOS that the data
written lies in an as yet unallocated block. If this is so, there is no data in the sector to
be destroyed so the read it skipped. If the pre-read is required, before reading the sector into
the buffer, there is another check that must be done by the BIOS as we shall see in a moment.
</p>
<p>
Having read the required physical sector, the buffer in use is set and the CP/M record may
be put in it at the appropriate place. You will see that the other records in the sector have now
been preserved. The BIOS doesn&rsquo;t write the buffer to disk at this point as another write to the
same physical sector may be requested by CP/M, so it simply flags this record as containing
unwritten data and returns control to CP/M.
</p>
<p>
If another write is requested to the same sector, the pre-read of the disk will not be required
as the wanted physical sector will already be is the buffer. However, if another write (or read) is
requested that involves a different physical sector, the BIOS looks at the flag showing whether the
buffer contains unwritten data and if it does, the BIOS now writes it to disk.
</p>
<p>
The only exception to the above explanation is when directory information is being written to
disk. Since the BIOS maintains a separate buffer for physical directory sectors, the changed
directory information MUST be written to disk immediately.
</p>
<p class="noindent center">
THE END&nbsp;!
</p>
<?php hLine("20%"); ?>
<?php columnEnd(1); ?>
<p></p>
<?php columnStart(23); ?>
<h2 id="article1">
A Review of two Modula 2s
</h2>
<?php columnChange(3); ?>
<h3 class="author">
by Doug Taylor
</h3>
<?php columnEnd(3); ?>
<?php columnStart(1); ?>
<p>
If you liken programming languages to cars, then Cobol is an Austin 7, old fashioned and
requiring a lot of maintenance, BASIC is a Fiat 127, noisy, prone to rust and always running out of
performance when you need it. Pascal is the Volvo of the programming world, careful, sale and
always willing to cruse up the hard shoulder at 90 MPH. Whereas Fortran 77 is a Range Rover,
bust go anywhere, do anything, break or remake all the rules language.
</p>
<p>
So where does Modula 2 fit? Well this is a kit car, built with strength of Volvo &ndash; it is
after all a member of the Algol family, a child of Nicklaus Wirth, but bas all the versatility of
Fortran. Modula 2 bas been used by Wirth to correct many of the mistakes of Pascal, the rather
fussy and confusing syntax has bees tidied up, (I could never remember when I needed a semicolon and
when I didn&rsquo;t) and the most powerful feature of Fortran, the foundation in library based code,
imported.
</p>
<p>
Modula 2, as it name suggest, encourages you to write modular code. These modules are
combined into libraries, and programs created by importing code into the program from these
libraries. The library will usually consist of Modula 2 code, it is a very recursive language,
Modula 2 code is made from Modula 2 code which is made from Modula 2 code which is&nbsp;...., but in most
if not all applications, code from other repeatable code producing tools can be linked into the
program, e.g. from an assembler or Fortran Compiler.
</p>
<p>
The two versions of Modula 2 I will review are Turbo Modula 2 from Borland International (only
available for CP/M at the moment) and FTL Modula 2 from Workman and Associates (<?php externalLink("HiSOFT","HiSoft"); ?> in the U.K.)
which is available for MSDOS and CP/M, the version reviewed being the MSDOS variant.
</p>
<p>
The Borland version of the language comes complete with a 544 page manual describing the
language, the Wordstar like editor, the shell and the Standard library supplied. The standard
library and reference directory to the modules is explained briefly with examples, covering 411
pages of the manual. If you have used Borland&rsquo;s other minor work Turbo Pascal you will know the language
high standard of their manuals &ndash; all examples in the manual will work and you can learn the language
from these alone.
</p>
<?php columnEnd(1); ?>
