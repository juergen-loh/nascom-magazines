<?php columnStart(1); ?>
<p>
block size depends on the individual computer system. The maximum length of a
block is limited only by the availability of memory to hold the block in the
computer. To identify a block on Phase Encoded and Croup Coded Recording there
is a preamble before the block and a postamble after the block. These are
recorded so that the machine knows where a block starts and where a block
finishes. Blocks are not numbered nor is there any record of their length. The
system works out the length of a block by counting the number of bytes read
between the preamble and the postamble.
</p>
<h4>
BOT/EOT
</h4>
<p>
The beginning and end of the data area of the tape are identified by a pice of
reflective foil stuck on the tape. This is seen by photoelectric sensors when
the marks pass. They are known as the BOT (Beginning Of Tape) and the EOT (End
Of Tape) markers. When the tape is first loaded (on the tape drives) the tape
is automatically moved so that the BOF mark is in front of the photoelectric
sensor. The first data block is located a short distance after the BOT mark.
Blocks are written one after the other separated by gaps. The purpose of the
gap is to separate blocks so that the blocks may be used one at a tine.
</p>
<h4>
File Marks or Tape Marks
</h4>
<p>
In order to divide the tape into files a special type of block is recorded &ndash;
this is called a file mark or tape mack. The file mark does not contain any
useful information. It is just a place marker. When a file mark is read a
special signal is sent from the tape deck to the host computer. This usually
causes reading to cease. The file mark is used to separate files on a tape. A
further use of the file mark is at the end of the data on a tape. Usually the
end of the recorded data on a tape is well before the reflective EOT marker. To
signify that there is no more valid date on the tape two or more file mark
blocks are written next to each other. If one file mark is encountered and the
system is asked to read the next file and another file mark is immediately
found, with no data block being read, the system knows that it has reached the
end of valid data. Some systems write several file marks at the end of data for
good measure.
</p>
<h4>
Adding Files to a Tape
</h4>
<p>
When a file is to be added to a tape, the tape is positioned to the file mark
just after the last file. When recording restarts all of the extra file marks
are overwritten. At the end of the new file multiple file marks are written.
</p>
<h4>
Headers, Volume Labele and Trailers
</h4>
<p>
As can be seen from the above, there is no directory system on a tape. It
merely consists of files recorded one after the other. This is quite
satisfactory for some applications when it is sufficient to stick a paper label
on the tape reel to identify the contents. Most scientific and engineering
applications find this adequate.
</p>
<p>
In commercial data processing departments where many more tapes are handled and
they are kept in big libraries a more formal scheme is required. A system of
Headers and Trailers has been developed so that each file in fact consists of 3
tape files. The first is the header, the second the data file itself, and the
third the trailer or &ldquo;End Of File header&rdquo;.
</p>
<p>
Each reel of tape is known as a Volume &ndash; just as with books. To identify the
volume the first header file on the tape has an additional record in the first
block and this is known as the Volume Label or Volume Header.
</p>
<p>
Another type of label that is encountered is the End of Volume. This is used
when it is necessary for s file to continue on to another volume of tape.
Instead of an end of file header at the end of data, the end of volume label is
used to signify that the file carries on to another tape volume.
</p>
<p>
The exact content of these headers varies from system to systen. Standards have
been produced by ANSI, ECMA, ISO and IBM. These are all similar in principle
but differ in detail. It will be found for instance that IBM use the EBCDIC
character representation instead of the ASCII used by the other.
</p>
<?php hline("20%"); ?>
<?php columnEnd(1); ?>
